{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://go-coverage-action/../../../../../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://go-coverage-action/external node-commonjs \"events\"","../webpack://go-coverage-action/external node-commonjs \"fs\"","../webpack://go-coverage-action/external node-commonjs \"path\"","../webpack://go-coverage-action/external node-commonjs \"readline\"","../webpack://go-coverage-action/webpack/bootstrap","../webpack://go-coverage-action/webpack/runtime/compat","../webpack://go-coverage-action/./index.js"],"sourcesContent":[null,"module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"readline\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\n\nconst events = require('events');\nconst {execa} = require('execa');\nconst fs = require('fs');\nconst path = require('path');\nconst readline = require('readline');\n\nconst {version} = require('./package.json');\n\n\n\nconst tmpdir = process.env['RUNNER_TEMP'];\nconst ctx = github.context;\n\n\nconst DATA_FMT_VERSION = 1;\n\n\nasync function exec(cmd, args, stdin) {\n  try {\n    const wd = core.getInput('working-directory');\n    core.startGroup(`$ ${cmd} ${args.join(' ')}`);\n    const subprocess = execa(cmd, args,\n      {\n        cwd: wd,\n        env: {\n          ...process.env,\n          'GIT_AUTHOR_NAME': 'Go Coverage Action',\n          'GIT_AUTHOR_EMAIL': '<>',\n          'GIT_COMMITTER_NAME': 'Go Coverage Action',\n          'GIT_COMMITTER_EMAIL': '<>',\n        },\n        all: true,\n        input: stdin,\n      });\n    subprocess.all.pipe(process.stdout);\n    const {all} = await subprocess;\n    return {output: all};\n  } catch (e) {\n    core.warning(`Failed to run ${cmd} ${args.join(' ')}`);\n    throw (e);\n  } finally {\n    core.endGroup();\n  }\n}\n\n\nasync function setup() {\n  await exec('go', ['version']);\n  await fetchCoverage();\n}\n\n\nasync function fetchCoverage() {\n  try {\n    await exec('git', ['fetch', 'origin',\n      '+refs/notes/gocoverage:refs/notes/gocoverage']);\n  } catch (e) {\n    // expected to fail if the ref hasn't been created yet\n    core.info('no existing gocoverage ref');\n  }\n}\n\n\nasync function setCoverageNote(data) {\n  const jsdata = JSON.stringify(data);\n  core.startGroup('new coverage raw data');\n  core.info(`new coverage data:  ${jsdata}`);\n  core.endGroup();\n  await fetchCoverage();\n  await exec('git', ['notes',\n    '--ref=gocoverage',\n    'add',\n    '-f', '--file=-', ctx.sha], jsdata);\n  await exec('git', ['push', 'origin', 'refs/notes/gocoverage']);\n}\n\n\nasync function getPriorCoverage() {\n  const stats = {'coverage_pct': null, 'pkg_stats': {}};\n  const pl = ctx.payload;\n  const ref = pl.pull_request ? pl.pull_request.base.sha : pl.before;\n  if (!ref) {\n    return stats;\n  }\n  try {\n    const {output} = await exec('git',\n      ['log',\n        '--notes=gocoverage',\n        '--pretty=format:%H%n%N',\n        '--grep=coverage_pct', '-n', '1', ref]);\n\n    try {\n      core.startGroup('prior coverage raw data');\n      core.info(`prior coverage data:  ${output}`);\n      core.endGroup();\n      const lines = output.split('\\n');\n      const sha = lines[0];\n      const data = JSON.parse(lines[1]);\n      data['sha'] = sha;\n      return data;\n    } catch (e) {\n      core.info(`failed to decode prior coverage: ${e}`);\n      return stats;\n    }\n  } catch (e) {\n    // git log may fail if an invalid ref is given; that's ok.\n  }\n  core.info(`no prior coverage found`);\n  return stats;\n}\n\nfunction packageDelta(prior, now) {\n  const priorPkgNames = Object.keys(prior);\n  const nowPkgNames = Object.keys(now);\n  const allNames = new Set(priorPkgNames.concat(nowPkgNames));\n  const pkgs = [];\n  for (const pkgName of [...allNames].sort()) {\n    const priorPct = prior[pkgName]?.[0] || 0;\n    const nowPct = now[pkgName]?.[0] || 0;\n    // only count as changed if delta is >0.1%\n    if (Math.abs(priorPct - nowPct) >= 0.1) {\n      pkgs.push([pkgName, priorPct, nowPct]);\n    }\n  }\n  return pkgs;\n}\n\nasync function generateCoverage() {\n  const report = {\n    'pkg_count': 0,\n    'with_tests': 0,\n    'no_tests': 0,\n    'skipped_count': 0,\n    'coverage_pct': 0,\n    'reportPathname': '',\n    'gocovPathname': '',\n    'gocovAggPathname': '',\n  };\n\n  report.gocovPathname = path.join(tmpdir, 'go.cov');\n  report.gocovAggPathname = path.join(tmpdir, 'go-aggregate.cov');\n\n  const filename = core.getInput('report-filename');\n  report.reportPathname = filename.startsWith('/') ? filename : path.join(tmpdir, filename);\n\n\n  const coverMode = core.getInput('cover-mode');\n  const coverPkg = core.getInput('cover-pkg');\n\n  let testArgs;\n  try {\n    testArgs = JSON.parse(core.getInput('test-args'));\n    if (!Array.isArray(testArgs)) {\n      throw ('not an array');\n    }\n  } catch (e) {\n    throw (`invalid value for test-args; must be a JSON array of strings, got ${testArgs} (${e})`);\n  }\n\n  const args = ['test'].concat(testArgs).concat([\n    '-covermode', coverMode,\n    '-coverprofile', report.gocovPathname,\n    ...(coverPkg ? ['-coverpkg', coverPkg] : []),\n    './...'\n  ]);\n  await exec('go', args);\n\n  const pkgStats = {};\n  const [globalPct, skippedFileCount, pkgStmts] = await calcCoverage(report.gocovPathname, report.gocovAggPathname);\n  for (const [pkgPath, [stmtCount, matchCount]] of Object.entries(pkgStmts)) {\n    report.pkg_count++;\n    pkgStats[pkgPath] = [matchCount / stmtCount * 100];\n    if (matchCount > 0) {\n      report.with_tests++;\n    } else {\n      report.no_tests++;\n    }\n  }\n  report.coverage_pct = globalPct;\n  report.pkg_stats = pkgStats;\n  report.skipped_count = skippedFileCount;\n\n  await exec('go', ['tool', 'cover', '-html', report.gocovPathname, '-o', report.reportPathname]);\n  core.info(`Generated ${report.reportPathname}`);\n\n  return report;\n}\n\n// parse the go.cov file to calculate \"true\" coverage figures per package\n// regardless of whether coverpkg is used.\nasync function calcCoverage(goCovFilename, aggFilename) {\n  const pkgStats = {};\n  const idCounts = {};\n  let globalStmts = 0; // number of statements globally\n  let globalCount = 0; // number of statements with coverage\n  let skippedFiles = new Set();\n\n  const wl = fs.createWriteStream(aggFilename);\n\n  const ignorePatterns = core.getMultilineInput('ignore-pattern').map(pat => new RegExp(pat.trim()));\n  core.info(`Ignoring ${ignorePatterns.length} filename patterns`);\n\n  const rl = readline.createInterface({\n    input: fs.createReadStream(goCovFilename),\n    crlfDelay: Infinity\n  });\n\n  const re = /^(.+) (\\d+) (\\d+)$/;\n  let mode = 'set';\n  rl.on('line', (line) => {\n    const m = line.match(re);\n    if (!m) {\n      const mm = line.match(/mode:\\s+(\\w+)/);\n      if (mm) {\n        mode = mm[1];\n        core.info(`Mode: ${mode}`);\n      }\n      return;\n    }\n    const id = m[1]; // statement identifier; pkgpath + stmt offset\n    const pkgPath = path.dirname(id);\n    const fn = id.split(':')[0];\n    for (const re of ignorePatterns) {\n      if (fn.match(re)) {\n        if (!skippedFiles.has(fn)) {\n          core.info('Skipping ' + fn);\n        }\n        skippedFiles.add(fn);\n        return;\n      }\n    }\n    const stmtCount = Number(m[2]);\n    const matchCount = Number(m[3]);\n    if (!pkgStats[pkgPath]) {\n      pkgStats[pkgPath] = [0, 0]; // stmts, covered\n    }\n    if (!idCounts[id]) {\n      globalStmts += stmtCount;\n      idCounts[id] = [stmtCount, 0];\n      pkgStats[pkgPath][0] += stmtCount;\n    }\n    if (matchCount > 0 && !idCounts[id][1]) {\n      globalCount += stmtCount;\n      pkgStats[pkgPath][1] += stmtCount;\n    }\n    idCounts[id][1] += matchCount;\n  });\n  await events.once(rl, 'close');\n\n  core.info(`Writing ${Object.keys(idCounts).length} keys`);\n  wl.write(`mode: ${mode}\\n`);\n  for (const id of Object.keys(idCounts).sort()) {\n    const [stmtCount, coverCount] = idCounts[id];\n    wl.write(`${id} ${stmtCount} ${mode == 'set' && coverCount ? 1 : coverCount}\\n`);\n  }\n  wl.end()\n\n  const globalPct = globalCount / globalStmts * 100;\n  core.info(`Totals stmts=${globalStmts} covered=${globalCount}, pct=${globalPct}`);\n  return [globalPct, skippedFiles.size, pkgStats];\n}\n\n\nconst commentMarker = '<!-- gocovaction -->';\n\nasync function generatePRComment(stats) {\n  let commitComment = `${commentMarker}Go test coverage: ${stats.current.coverage_pct.toFixed(1)}% for commit ${ctx.sha}`;\n\n  if (stats.prior.coverage_pct != null) {\n    core.info(`Previous coverage: ${stats.prior.coverage_pct}% as of ${stats.prior.sha}`);\n\n    commitComment = `${commentMarker}:arrow_right: Go test coverage stayed the same at ${stats.current.coverage_pct.toFixed(1)}% compared to ${stats.prior.sha}`;\n    if (stats.deltaPct > 0) {\n      commitComment = `${commentMarker}:arrow_up: Go test coverage increased from ${stats.prior.coverage_pct.toFixed(1)}% to ${stats.current.coverage_pct.toFixed(1)}% compared to ${stats.prior.sha}`;\n    } else if (stats.deltaPct < 0) {\n      commitComment = `${commentMarker}:arrow_down: Go test coverage decreased from ${stats.prior.coverage_pct.toFixed(1)}% to ${stats.current.coverage_pct.toFixed(1)}% compared to ${stats.prior.sha}`;\n    }\n    if (stats.current.skipped_count > 0) {\n      commitComment += ` <i>(${stats.current.skipped_count} ignored files)</i>`;\n    }\n  } else {\n    core.info('No prior coverage information found in log');\n  }\n  if (stats.current.no_tests > 0) {\n    commitComment += `\\n<details><summary>:warning: ${stats.current.no_tests} of ${stats.current.pkg_count} packages have zero coverage.</summary>\\n\\n`;\n    for (const pkgName of Object.keys(stats.current.pkg_stats).sort()) {\n      if (stats.current.pkg_stats[pkgName] == 0) {\n        commitComment += `* ${pkgName}\\n`;\n      }\n    }\n    commitComment += `\\n</details>\\n`;\n  }\n\n  if (!stats.meetsThreshold) {\n    commitComment += `\\n:no_entry: Coverage does not meet minimum requirement of ${stats.minPct}%.\\n`;\n  }\n\n  const reportUrl = core.getInput('report-url');\n  if (reportUrl) {\n    commitComment += `\\n\\n[View full coverage report](${reportUrl})\\n`;\n  }\n\n\n  if (stats.prior.coverage_pct !== null) {\n    const delta = packageDelta(stats.prior.pkg_stats, stats.current.pkg_stats);\n    if (delta.length) {\n      const maxPkgLen = Math.max.apply(null, delta.map(pkg => pkg[0].length));\n      commitComment += '\\nUpdated Package Coverages:\\n\\n```diff\\n';\n      commitComment += `# ${'Package Name'.padEnd(maxPkgLen, ' ')} |  Prior |    New\\n`;\n      for (const pkg of delta) {\n        const [pkgName, priorPct, newPct] = pkg;\n        const priorPctFmt = priorPct.toFixed(1).padStart(5, ' ') + '%';\n        const newPctFmt = newPct.toFixed(1).padStart(5, ' ') + '%';\n        commitComment += `${newPct >= priorPct ? '+' : '-'} ${pkgName.padEnd(maxPkgLen, ' ')} | ${priorPctFmt} | ${newPctFmt}\\n`;\n      }\n      commitComment += '```\\n\\n';\n    } else {\n      commitComment += `\\nNo change in coverage for any package.\\n\\n`;\n    }\n  }\n\n  const allMaxPkgLen = Math.max.apply(null, Object.keys(stats.current.pkg_stats).map(pkgName => pkgName.length));\n  commitComment += '<details><summary>View coverage for all packages</summary>\\n';\n  commitComment += '\\n```diff\\n'\n  commitComment += `# ${'Package Name'.padEnd(allMaxPkgLen, ' ')} | Coverage\\n`;\n  for (const pkgName of Object.keys(stats.current.pkg_stats).sort()) {\n    const pct = stats.current.pkg_stats[pkgName][0];\n    commitComment += `${pct > 0 ? '+' : '-'} ${pkgName.padEnd(allMaxPkgLen, ' ')} |   ${pct.toFixed(1).padStart(5, ' ')}%\\n`;\n  }\n  commitComment += '```\\n</details>\\n\\n';\n\n  return commitComment;\n\n}\n\n\nasync function findPreviousComment(octokit, issue_number) {\n  const it = octokit.paginate.iterator(octokit.rest.issues.listComments, {\n    owner: ctx.payload.repository.owner.login,\n    repo: ctx.payload.repository.name,\n    issue_number: issue_number,\n    per_page: 100\n  });\n\n  for await (const {data: comments} of it) {\n    for (const comment of comments) {\n      if (comment.body.startsWith(commentMarker)) {\n        return comment.id;\n      }\n    }\n  }\n  return null;\n}\n\nasync function generateReport() {\n  await setup();\n\n  const current = await generateCoverage();\n  const prior = await getPriorCoverage();\n  const minPct = Number(core.getInput('coverage-threshold'));\n  const deltaPct = current.coverage_pct - prior.coverage_pct;\n\n  const stats = {\n    current,\n    prior,\n    deltaPct,\n    minPct,\n    meetsThreshold: current.coverage_pct > minPct,\n    deltaPctFmt: Intl.NumberFormat('en-US', {signDisplay: 'exceptZero'}).format(deltaPct)\n  };\n\n\n  core.info(`Found ${stats.current.pkg_count} packages`);\n  core.info(`Packages with tests: ${stats.current.with_tests}`);\n  core.info(`Packages with zero tests: ${stats.current.no_tests}`);\n  core.info(`Total coverage: ${stats.current.coverage_pct.toFixed(1)}%`);\n  core.info(`Minimum required coverage: ${stats.minPct}%`);\n  core.info(`Coverage delta: ${stats.deltaPctFmt}%`);\n\n  core.startGroup('Set output values');\n  core.setOutput('coverage-pct', stats.current.coverage_pct);\n  core.setOutput('package-count', stats.current.pkg_count);\n  core.setOutput('uncovered-packages', stats.current.no_tests);\n\n  core.setOutput('coverage-delta', stats.deltaPct);\n  core.setOutput('coverage-last-pct', stats.prior.coverage_pct);\n  core.setOutput('coverage-last-sha', stats.prior.sha);\n  core.setOutput('meets-threshold', stats.meetsThreshold);\n  core.setOutput('gocov-pathname', current.gocovPathname);\n  core.setOutput('gocov-agg-pathname', current.gocovAggPathname);\n  core.setOutput('report-pathname', current.reportPathname);\n  core.endGroup();\n\n  const nowData = {\n    'go-coverage-action-fmt': DATA_FMT_VERSION,\n    'coverage_pct': current.coverage_pct,\n    'pkg_stats': current.pkg_stats,\n    'skipped_count': current.skipped_count,\n  };\n  await setCoverageNote(nowData);\n\n\n  if (!stats.meetsThreshold) {\n    const fail_policy = core.getInput('fail-coverage');\n    if (fail_policy == 'always' || (fail_policy == 'only_pull_requests' && ctx.payload.pull_request)) {\n      core.setFailed(`Code coverage of ${stats.current.coverage_pct.toFixed(1)}% falls below minimum required coverage of ${stats.minPct}%`);\n    } else {\n      core.warning(`Code coverage of ${stats.current.coverage_pct.toFixed(1)}% falls below minimum required coverage of ${stats.minPct}%`);\n    }\n  }\n\n\n\n  const comment = await generatePRComment(stats);\n  await core.summary\n    .addRaw(comment)\n    .write();\n\n  if (core.getBooleanInput('add-comment') && ctx.payload.pull_request) {\n    const token = core.getInput('token');\n    const octokit = github.getOctokit(token);\n    const pr_number = ctx.payload.pull_request.number;\n    const prev_comment_id = await findPreviousComment(octokit, pr_number);\n    if (prev_comment_id) {\n      core.info(`Updating existing comment id ${prev_comment_id}`);\n      await octokit.rest.issues.updateComment({\n        owner: ctx.payload.repository.owner.login,\n        repo: ctx.payload.repository.name,\n        comment_id: prev_comment_id,\n        body: comment\n      });\n    } else {\n      core.info('Creating new comment');\n      await octokit.rest.issues.createComment({\n        owner: ctx.payload.repository.owner.login,\n        repo: ctx.payload.repository.name,\n        issue_number: pr_number,\n        body: comment,\n      });\n    }\n  }\n}\n\n\n\nasync function run() {\n  try {\n    core.info(`Running go-coverage-action version ${version}`);\n\n    await generateReport();\n  } catch (e) {\n    core.setFailed(e);\n  }\n}\n\n\nrun();\n"],"names":[],"sourceRoot":""}